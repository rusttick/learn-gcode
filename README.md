# Learn Gcode

Here are my machine instruction experiments as I add motors and controls to an old Tree 2uvrc milling machine while attempting to avoid a crash.
I started with manually written commands and then began editing freecad path generated files as I add motors and limit switches to each axis.
Eventually I hope to use the output of freecad path directly.


Do not load anything from this repository on your machine. These files will destroy your machine. If you break your machine, you get to keep both pieces.

# Note

It took me a while to understand the division of responsibility of each software component, so I will record my current understanding here:

* Closed-loop stepper motors and drivers move the lead screws of the machine in 1.8 degree increments for each pulse input they receive.
* The "Motion Controller" (GRBL in this case) implements some version/subset of the NIST RS274 (gcode) machine control interface which accepts commands analogous to "move the cutting tool 2 inches to the left" etc... and then sends pulses to the stepper drivers. The motion controller may take limited responsibility for protecting the machine from the user, but in order to remain effective at step generation, it cannot perform much path analysis or collision detection.
* The UI for the system could be gcode over a serial connection, but gcode is not a turing complete programming language and even simple machine operations quickly become tedious. Instead, a more convienent graphical UI (cncjs in this case) accepts files with gcode commands, displays a graphical representation of the planned toolpaths, displays the machine state, and allows button control like jogging, cycle-start, etc...
* Why is the UI separate from the motion controller? The UI runs on a normal desktop OS and CPU with priority scheduling systems and throughput optimizations that negatively impact the timing, latency, and reliability of command execution to meet the needs of user interfaces. To be successful, the motion controller must be minimal and run on its own CPU with firmware specifically designed around the accurate timing needed to send pulses to stepper drivers. The interface split at a minimal, low-level language is a result of this focus on timing.
* A CAM program analyzes a CAD model, generates its own, internal representation of how it thinks the machine should move in order to create the modeled object, and then generates gcode for the machine controller. The gcode generated by CAM is often long and difficult to read. CAM and the machine UI share the responsibility of visualizing the planned machine moves. Ideally, they would both have a detailed understanding of the machine and work to avoid crashes, but this is not always the case.

In summary, the milling machine workflow is roughly:

```
CAD -> CAM -> UI -> controller -> drivers -> motors
```

... to the best of my current understanding


# Software

The mill controller is an arduino mega 2560 running grbl with backlash compensation from:

https://github.com/shooter64738/grbl-mega


The mill web UI is cncjs runing on a raspberry pi connected to the arduino via USB:

https://cnc.js.org


# Config

Here are the current machine settings after some linear distance and backlash calibration:

```
CNCjs 1.10.3 [Grbl]
Connected to /dev/ttyACM0 with a baud rate of 115200
Grbl 1.1h(backlash comp) ['$' for help]
client> $$
$0=10 (Step pulse time, microseconds)
$1=254 (Step idle delay, milliseconds)
$2=0 (Step pulse invert, mask)
$3=7 (Step direction invert, mask)
$4=0 (Invert step enable pin, boolean)
$5=1 (Invert limit pins, boolean)
$6=0 (Invert probe pin, boolean)
$10=1 (Status report options, mask)
$11=0.010 (Junction deviation, millimeters)
$12=0.002 (Arc tolerance, millimeters)
$13=1 (Report in inches, boolean)
$20=0 (Soft limits enable, boolean)
$21=1 (Hard limits enable, boolean)
$22=0 (Homing cycle enable, boolean)
$23=0 (Homing direction invert, mask)
$24=25.000 (Homing locate feed rate, mm/min)
$25=500.000 (Homing search seek rate, mm/min)
$26=250 (Homing switch debounce delay, milliseconds)
$27=1.000 (Homing switch pull-off distance, millimeters)
$30=2000 (Maximum spindle speed, RPM)
$31=500 (Minimum spindle speed, RPM)
$32=0 (Laser-mode enable, boolean)
$100=314.870 (X-axis travel resolution, step/mm)
$101=314.870 (Y-axis travel resolution, step/mm)
$102=15600.000 (Z-axis travel resolution, step/mm)
$110=2286.000 (X-axis maximum rate, mm/min)
$111=2286.000 (Y-axis maximum rate, mm/min)
$112=63.5.000 (Z-axis maximum rate, mm/min)
$120=80.000 (X-axis acceleration, mm/sec^2)
$121=80.000 (Y-axis acceleration, mm/sec^2)
$122=4.000 (Z-axis acceleration, mm/sec^2)
$130=200.000 (X-axis maximum travel, millimeters)
$131=200.000 (Y-axis maximum travel, millimeters)
$132=200.000 (Z-axis maximum travel, millimeters)
$140=0.430
$141=0.190
$142=0.130
ok
```

# Future work

* finish the Z axis
* install a second Z axis on the quill to allow peck drilling without wearing out the column ways
* failure testing: ensure that all component failures can be detected and will lead to a safe machine shutdown
* Minimum Quantity Lubrication and chip clearing for carbide cutting tools: air/mist etc...
* Mill Enclosure and cleaning
* Improve CAM/UI colision detection
* replace the Head/spindle and allow for ATC
* CNC lathe
* CNC wood tools
* CNC plasma
* CNC welding
